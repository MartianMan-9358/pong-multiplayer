<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Pong — PlayroomKit lobby test + basic game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { background:#111; color:#fff; text-align:center; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    canvas { display:block; margin:18px auto; background:#000; border:1px solid #333; }
    button { padding:8px 14px; font-size:15px; margin:8px; }
    #diag { position:fixed; right:12px; top:12px; background:#222; color:#fff; padding:8px 10px;
            font-family:monospace; font-size:13px; z-index:9999; border-radius:6px; max-width:420px; white-space:pre-wrap; }
  </style>
</head>
<body>
  <h1>Pong</h1>
  <p>Player 1: W/S — Player 2: ↑/↓</p>
  <div><button id="join">Create / Join game (shows lobby)</button></div>
  <canvas id="game" width="800" height="500"></canvas>
  <div id="diag">booting…</div>

  <script src="https://unpkg.com/react/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/playroomkit/multiplayer.full.umd.js"></script>
  <script>
  (function () {
    const diagEl = document.getElementById('diag');
    const joinBtn = document.getElementById('join');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const PADDLE_H = 100, PADDLE_W = 12, BALL_R = 8;

    const log = (...a) => console.log(...a);
    const diag = msg => { diagEl.textContent = msg; log('[DIAG]', msg); };

    if (!window.Playroom) { diag('PlayroomKit missing — check CDN URL and hard-reload.'); return; }
    const { insertCoin, myPlayer, isHost, onPlayerJoin } = window.Playroom;

    const state = {
      ball: { x: W/2, y: H/2, vx: 4, vy: 3 },
      paddles: { p1: { y: (H-PADDLE_H)/2 }, p2: { y: (H-PADDLE_H)/2 } },
      scores: { p1: 0, p2: 0 },
      slot: null,
      hosting: false
    };

    let room = null, joined = false, hostTick = null;
    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup',   e => keys[e.code] = false);

    function draw() {
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
      ctx.strokeStyle = '#333'; ctx.setLineDash([8,12]); ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke(); ctx.setLineDash([]);
      ctx.fillStyle = '#fff';
      ctx.fillRect(20, state.paddles.p1.y, PADDLE_W, PADDLE_H);
      ctx.fillRect(W - 20 - PADDLE_W, state.paddles.p2.y, PADDLE_W, PADDLE_H);
      ctx.beginPath(); ctx.arc(state.ball.x, state.ball.y, BALL_R, 0, Math.PI*2); ctx.fill();
      ctx.font = '20px monospace';
      ctx.fillText(state.scores.p1, W*0.25, 30);
      ctx.fillText(state.scores.p2, W*0.75, 30);
    }

    function applyLocalInput() {
      const clamp = y => Math.max(0, Math.min(H - PADDLE_H, y));
      if (state.slot === 'p1') { if (keys['KeyW']) state.paddles.p1.y -= 6; if (keys['KeyS']) state.paddles.p1.y += 6; state.paddles.p1.y = clamp(state.paddles.p1.y); }
      if (state.slot === 'p2') { if (keys['ArrowUp']) state.paddles.p2.y -= 6; if (keys['ArrowDown']) state.paddles.p2.y += 6; state.paddles.p2.y = clamp(state.paddles.p2.y); }
    }

    function throttle(fn, ms) { let last = 0; return (...args) => { const now = Date.now(); if (now - last >= ms) { last = now; fn(...args); } }; }

    const publishMyPaddle = throttle(() => {
      if (!room) return;
      const me = myPlayer && myPlayer();
      if (!me || typeof me.index !== 'number') return;
      const key = `paddle_${me.index}`;
      const y = (me.index === 0) ? state.paddles.p1.y : state.paddles.p2.y;
      try { room.setState(key, { y }); } catch(e) { console.warn('[WARN] setState paddle failed', e); }
    }, 80);

    function startHost() {
      if (hostTick) return;
      state.hosting = true;
      diag('Host running');
      hostTick = setInterval(() => {
        const b = state.ball;
        b.x += b.vx; b.y += b.vy;
        if (b.y < BALL_R || b.y > H - BALL_R) b.vy *= -1;
        const p1X = 20 + PADDLE_W, p2X = W - 20 - PADDLE_W;
        const hitP1 = (b.x - BALL_R < p1X && b.y > state.paddles.p1.y && b.y < state.paddles.p1.y + PADDLE_H);
        const hitP2 = (b.x + BALL_R > p2X && b.y > state.paddles.p2.y && b.y < state.paddles.p2.y + PADDLE_H);
        if (hitP1) b.vx = Math.abs(b.vx);
        if (hitP2) b.vx = -Math.abs(b.vx);
        if (b.x < 0) { state.scores.p2++; Object.assign(b, { x: W/2, y: H/2, vx: 4, vy: 3 }); }
        if (b.x > W) { state.scores.p1++; Object.assign(b, { x: W/2, y: H/2, vx: -4, vy: -3 }); }
        if (room) {
          try { room.setState('ball', { x: b.x, y: b.y, vx: b.vx, vy: b.vy, ts: Date.now() }); room.setState('scores', state.scores); }
          catch(e) { console.warn('[WARN] host setState failed', e); }
        }
      }, 1000 / 60);
    }

    function stopHost() { state.hosting = false; if (hostTick) { clearInterval(hostTick); hostTick = null; diag('Host stopped'); } }

    function hookSubscriptions() {
      room.onStateChange('paddle_0', val => { if (val) state.paddles.p1 = { ...state.paddles.p1, ...val }; });
      room.onStateChange('paddle_1', val => { if (val) state.paddles.p2 = { ...state.paddles.p2, ...val }; });
      room.onStateChange('ball', val => { if (val && !state.hosting) state.ball = { ...state.ball, ...val }; });
      room.onStateChange('scores', val => { if (val) state.scores = { ...val }; });
    }

    function assignSlotFromMe() {
      const me = myPlayer && myPlayer();
      if (me && typeof me.index === 'number') { state.slot = (me.index === 0) ? 'p1' : 'p2'; log('[SLOT] I am', state.slot, 'index', me.index); }
    }

    async function join() {
      if (joined) { diag('Already joined'); return; }
      joined = true;
      diag('Joining… (lobby should appear)');

      try {
        room = await insertCoin({ gameId: 'pongvanilla' });
        //room = await insertCoin({ gameId: 'drawinggame' });
      } catch (err) {
        console.error('[JOIN] insertCoin error', err);
        diag('Join failed — see console');
        joined = false;
        return;
      }

      if (!room) { diag('insertCoin returned null (no room).'); joined = false; return; }

      hookSubscriptions();
      assignSlotFromMe();
      if (isHost && isHost()) startHost(); else stopHost();

      onPlayerJoin(player => {
        const me = myPlayer && myPlayer();
        if (me && player.id === me.id && typeof player.index === 'number') {
          state.slot = (player.index === 0) ? 'p1' : 'p2';
          log('[EVENT] My slot updated:', state.slot);
        }
        if (isHost && isHost()) startHost(); else stopHost();
      });

      diag(`Joined — slot:${state.slot || 'unknown'} ${isHost && isHost() ? '(host)' : ''}`);
    }

    function loop() { applyLocalInput(); publishMyPaddle(); draw(); requestAnimationFrame(loop); }
    joinBtn.onclick = () => { log('[UI] Join clicked'); join(); };
    diag('Ready — click "Create / Join game" to start');
    loop();
  })();
  </script>
</body>
</html>
