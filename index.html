<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Pong + Playroom Minimal — Local UMD + Deep Logs</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { background:#111; color:#fff; text-align:center; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    canvas { display:block; margin:18px auto; background:#000; border:1px solid #333; }
    button { padding:8px 14px; font-size:15px; margin:8px; }
    #diag { position:fixed; right:12px; top:12px; background:#222; color:#fff; padding:8px 10px; font-family:monospace; font-size:13px; z-index:9999; border-radius:6px; max-width:360px; white-space:pre-wrap; }
  </style>
</head>
<body>
  <div>
    <button id="join">Join / Launch</button>
  </div>
  <canvas id="c" width="800" height="500"></canvas>
  <div id="diag">idle</div>

  <!-- React + ReactDOM required by PlayroomKit UMD -->
  <script src="https://unpkg.com/react/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom/umd/react-dom.production.min.js"></script>

  <!-- PlayroomKit UMD (local copy hosted in your repo) -->
  <script src="./playroomkit.umd.js"></script>

  <!-- Sanity check: confirm SDK is present -->
  <script>
    console.log('[BOOT] Playroom on window:', window.Playroom);
    document.getElementById('diag').textContent =
      'boot — Playroom ' + (window.Playroom ? 'OK' : 'MISSING');
  </script>

  <script>
  (function () {
    const diagEl = document.getElementById('diag');
    const log = (...a) => { console.log(...a); };
    const diag = (msg) => { diagEl.textContent = msg; log('[DIAG]', msg); };

    if (!window.Playroom) {
      diag('Playroom missing — check that playroomkit.umd.js is served from your domain.');
      return;
    }

    const { insertCoin, onPlayerJoin, myPlayer, isHost } = window.Playroom;

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const joinBtn = document.getElementById('join');

    const W = canvas.width, H = canvas.height;
    const PADDLE_H = 100, PADDLE_W = 12;

    const state = {
      ball: { x: W/2, y: H/2, vx: 4, vy: 3 },
      paddles: { p1: { y: (H - PADDLE_H)/2 }, p2: { y: (H - PADDLE_H)/2 } },
      scores: { p1: 0, p2: 0 },
      slot: null,
      hosting: false
    };

    let room = null;
    let joined = false;
    let hostTick = null;

    const keys = Object.create(null);
    window.addEventListener('keydown', e => { keys[e.code] = true; });
    window.addEventListener('keyup',   e => { keys[e.code] = false; });

    function draw() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = '#fff';
      ctx.fillRect(20, state.paddles.p1.y, PADDLE_W, PADDLE_H);
      ctx.fillRect(W - 20 - PADDLE_W, state.paddles.p2.y, PADDLE_W, PADDLE_H);

      ctx.beginPath();
      ctx.arc(state.ball.x, state.ball.y, 8, 0, Math.PI*2);
      ctx.fill();

      ctx.font = '20px monospace';
      ctx.fillText(state.scores.p1, W*0.25, 30);
      ctx.fillText(state.scores.p2, W*0.75, 30);
    }

    function applyLocalInput() {
      if (state.slot === 'p1') {
        if (keys['KeyW']) state.paddles.p1.y -= 6;
        if (keys['KeyS']) state.paddles.p1.y += 6;
        state.paddles.p1.y = Math.max(0, Math.min(H - PADDLE_H, state.paddles.p1.y));
      } else if (state.slot === 'p2') {
        if (keys['ArrowUp']) state.paddles.p2.y -= 6;
        if (keys['ArrowDown']) state.paddles.p2.y += 6;
        state.paddles.p2.y = Math.max(0, Math.min(H - PADDLE_H, state.paddles.p2.y));
      }
    }

    function throttle(fn, ms) {
      let last = 0;
      return (...a) => {
        const now = Date.now();
        if (now - last >= ms) { last = now; fn(...a); }
      };
    }

    const publishMyPaddle = throttle(() => {
      if (!room) return;
      const me = myPlayer && myPlayer();
      if (!me || typeof me.index !== 'number') return;
      const key = `paddle_${me.index}`;
      const y = (me.index === 0) ? state.paddles.p1.y : state.paddles.p2.y;
      try {
        room.setState(key, { y });
        log('[NET] publish paddle', key, y);
      } catch(e) {
        console.warn('[WARN] setState failed', e);
      }
    }, 80);

    function startHost() {
      if (hostTick) return;
      state.hosting = true;
      diag('host: running');

      hostTick = setInterval(() => {
        const b = state.ball;
        b.x += b.vx; b.y += b.vy;
        if (b.y < 8 || b.y > H - 8) b.vy *= -1;

        if (b.x - 8 < 20 + PADDLE_W && b.y > state.paddles.p1.y && b.y < state.paddles.p1.y + PADDLE_H) b.vx = Math.abs(b.vx);
        if (b.x + 8 > W - 20 - PADDLE_W && b.y > state.paddles.p2.y && b.y < state.paddles.p2.y + PADDLE_H) b.vx = -Math.abs(b.vx);

        if (b.x < 0) {
          state.scores.p2++;
          Object.assign(b, { x: W/2, y: H/2, vx: 4, vy: 3 });
        }
        if (b.x > W) {
          state.scores.p1++;
          Object.assign(b, { x: W/2, y: H/2, vx: -4, vy: -3 });
        }

        if (room) {
          try {
            room.setState('ball', { x: b.x, y: b.y, vx: b.vx, vy: b.vy, ts: Date.now() });
            room.setState('scores', state.scores);
          } catch(e) {
            console.warn('[WARN] host setState failed', e);
          }
        }
      }, 1000 / 60);
    }

    function stopHost() {
      state.hosting = false;
      if (hostTick) { clearInterval(hostTick); hostTick = null; diag('host: stopped'); }
    }

    function hookPaddles() {
      room.onStateChange('paddle_0', val => {
        if (!val) return;
        state.paddles.p1 = { ...state.paddles.p1, ...val };
        log('[SUB] paddle_0', val);
      });
      room.onStateChange('paddle_1', val => {
        if (!val) return;
        state.paddles.p2 = { ...state.paddles.p2, ...val };
        log('[SUB] paddle_1', val);
      });
    }

    function hookBallAndScores() {
      room.onStateChange('ball', val => {
        if (!val) return;
        if (!state.hosting) {
          state.ball = { ...state.ball, ...val };
          log('[SUB] ball', val);
        } else {
          log('[SUB] ball ignored (host)', val);
        }
      });
      room.onStateChange('scores', val => {
        if (val) {
          state.scores = { ...val };
          log('[SUB] scores', val);
        }
      });
    }

    async function join() {
      if (joined) { diag('already joined'); return; }
      joined = true;
      diag('joining… click overlay Launch if shown');

      let attempt = 0;
      let lastErr = null;
      for (; attempt < 3; attempt++) {
        try {
          log('[JOIN] insertCoin attempt', attempt + 1);
          //room = await insertCoin();
          room = await insertCoin({ gameId: "pong-multiplayer", skipLobby: true });
          if (room) break;
        } catch (err) {
          lastErr = err;
          console.error('[JOIN] insertCoin error', err);
        }
        diag('waiting for room… retrying');
        await new Promise(r => setTimeout(r, 700));
      }

      if (!room) {
        diag('No room — ensure overlay completed, then click Join again');
        console.error('[JOIN] room null after retries', lastErr);
        joined = false;
        return;
      }

      log('[JOIN] room acquired:', room);
      diag('room acquired — hooking state');

      hookBallAndScores();
      hookPaddles();

      const me = myPlayer && myPlayer();
      log('[JOIN] myPlayer()', me);
      if (me && typeof me.index === 'number') {
        state.slot = (me.index === 0) ? 'p1' : 'p2';
        log('[JOIN] assigned slot', state.slot, 'index', me.index);
      } else {
        log('[JOIN] myPlayer not ready yet — will wait for onPlayerJoin');
      }

      if (isHost && isHost()) { startHost(); } else { stopHost(); }
      log('[JOIN] isHost?', isHost && isHost());

      onPlayerJoin((player) => {
        log('[EVENT] onPlayerJoin', player);
        const me2 = myPlayer && myPlayer();
        if (me2 && player.id === me2.id && typeof player.index === 'number') {
          state.slot = (player.index === 0) ? 'p1' : 'p2';
          log('[EVENT] slot updated via onPlayerJoin:', state.slot);
        }
        if (isHost && isHost()) startHost(); else stopHost();
      });

      diag('joined — slot: ' + (state.slot || 'unknown') + ((isHost && isHost()) ? ' (host)' : ''));
      log('[JOIN] complete. URL:', location.href);
    }

    function loop() {
      applyLocalInput();
      publishMyPaddle();
      draw();
      requestAnimationFrame(loop);
    }

    joinBtn.onclick = () => {
      log('[UI] Join clicked');
      join();
    };

    loop();

    setInterval(() => {
      log('[TICK]', { slot: state.slot, hosting: state.hosting, room: !!room });
      diag('slot:' + (state.slot || '∅') + ' hosting:' + (state.hosting ? 'Y' : 'N') + ' room:' + (!!room));
    }, 3000);
  })();
  </script>
</body>
</html>
